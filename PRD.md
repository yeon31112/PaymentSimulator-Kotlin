# 제품 요구사항 문서 (PRD): 간단한 결제 시스템 시뮬레이터

## 1. 소개

### 1.1 목적
결제 시스템 시뮬레이터는 전자상거래 결제 시스템의 핵심 기능을 모방하는 백엔드 애플리케이션입니다. Kotlin, Spring Boot, REST API 개발을 실습하며 사용자 인증, 결제 처리, 트랜잭션 상태 관리와 같은 실제 결제 워크플로우를 시뮬레이션하는 것을 목표로 합니다. 이 프로젝트는 백엔드 개발 직무 지원을 위한 포트폴리오로 활용됩니다.

### 1.2 범위
시뮬레이터는 다음을 포함합니다:
- 결제 시작, 확인, 상태 조회를 위한 REST API.
- 결제 작업 보안을 위한 사용자 인증.
- 관계형 데이터베이스(MySQL 또는 H2)를 사용한 트랜잭션 관리.
- 결제 실패 시 오류 처리 및 사용자 피드백.
- API 엔드포인트에 대한 기본 테스트 및 문서화.

다음은 제외됩니다:
- 실제 결제 게이트웨이(예: Stripe, PayPal) 연동.
- 프론트엔드 인터페이스(백엔드 API에 초점).
- 환불 또는 정기 결제와 같은 고급 기능.

### 1.3 대상 사용자
- **주요 사용자**: 개발자(본인) 및 백엔드 엔지니어 직무 채용 담당자.
- **사용 사례**: Kotlin, Spring Boot, REST API 설계, 결제 시스템 로직에 대한 숙련도를 보여주기 위해, 특히 당근페이의 Software Engineer, Backend 직무 지원 시 활용.

## 2. 목표 및 목적

### 2.1 목표
- 결제 워크플로우를 시뮬레이션하는 기능적 백엔드 시스템을 구축하여 결제 도메인을 이해.
- Kotlin, Spring Boot 및 관련 기술(JPA, Spring Security) 실습 경험 획득.
- API 설계, 오류 처리, 테스트 역량을 전문 포트폴리오로 입증.

### 2.2 목적
- [목표 완료 날짜]까지 결제 작업을 위한 최소 3개의 REST API 엔드포인트를 구현.
- JUnit과 Postman을 사용해 API 테스트 커버리지 90% 이상 달성.
- GitHub README와 Swagger로 API 문서화.
- 트랜잭션 충돌 등 실제 시나리오를 모방한 기본 동시성 처리 구현.

## 3. 기능 요구사항

### 3.1 사용자 인증
- **설명**: 사용자는 결제를 시작하기 위해 인증을 거쳐야 하며, 보안 접근을 보장.
- **기능**:
  - `/auth/login`: 유효한 자격 증명으로 JWT 토큰을 생성하는 POST 엔드포인트.
  - Spring Security를 사용해 모든 결제 API를 JWT 기반 인증으로 보호.
- **수용 기준**:
  - 유효한 자격 증명은 1시간 만료 JWT 토큰을 반환.
  - 유효하지 않은 자격 증명은 401 Unauthorized 오류 반환.
  - 유효한 토큰 없는 결제 API 요청은 403 Forbidden 반환.

### 3.2 결제 시작
- **설명**: 사용자는 가상 제품에 대한 결제를 시작할 수 있음.
- **기능**:
  - `/payment/init`: 금액과 제품 ID로 결제 요청을 생성하는 POST 엔드포인트.
  - 결제 금액(양수 여부)과 제품 가용성(모의 데이터) 검증.
  - 초기 트랜잭션 상태(PENDING)를 데이터베이스에 저장.
- **수용 기준**:
  - 성공 요청은 트랜잭션 ID와 함께 201 Created 응답 반환.
  - 유효하지 않은 입력(예: 음수 금액)은 400 Bad Request와 오류 메시지 반환.
  - 트랜잭션은 PENDING 상태로 데이터베이스에 저장.

### 3.3 결제 확인
- **설명**: 사용자는 결제를 확인하여 성공 또는 실패를 시뮬레이션.
- **기능**:
  - `/payment/confirm/{transactionId}`: 결제를 확인하는 POST 엔드포인트.
  - 모의 검증(예: 잔액 충분 여부)에 따라 트랜잭션 상태를 SUCCESS 또는 FAILED로 업데이트.
  - 실패한 결제에 대해 트랜잭션 롤백 처리.
- **수용 기준**:
  - 유효한 확인은 트랜잭션을 SUCCESS로 업데이트하고 200 OK 응답 반환.
  - 실패 확인은 FAILED로 업데이트, 변경 사항 롤백, 400 Bad Request 반환.
  - 존재하지 않는 트랜잭션 ID는 404 Not Found 반환.

### 3.4 결제 상태 조회
- **설명**: 사용자는 결제 상태를 확인할 수 있음.
- **기능**:
  - `/payment/status/{transactionId}`: 트랜잭션 세부 정보를 조회하는 GET 엔드포인트.
  - 트랜잭션 ID, 금액, 상태(PENDING, SUCCESS, FAILED), 타임스탬프 반환.
- **수용 기준**:
  - 유효한 트랜잭션 ID는 트랜잭션 세부 정보와 함께 200 OK 응답 반환.
  - 유효하지 않은 트랜잭션 ID는 404 Not Found 반환.
  - 응답은 사용자 친화적인 상태 정보 포함.

### 3.5 데이터베이스 관리
- **설명**: 결제 및 사용자 데이터를 관계형 데이터베이스에 저장 및 관리.
- **기능**:
  - JPA를 사용해 MySQL(또는 로컬 개발용 H2)에 사용자 및 트랜잭션 저장.
  - 테이블: `users` (ID, 사용자 이름, 비밀번호 해시), `transactions` (ID, 사용자 ID, 금액, 상태, 타임스탬프).
- **수용 기준**:
  - 데이터베이스 스키마는 필요한 필드와 관계를 지원.
  - JPA는 엔터티를 올바르게 매핑하고 CRUD 작업 처리.
  - 트랜잭션은 데이터 불일치를 방지하도록 격리.

## 4. 비기능 요구사항

### 4.1 성능
- 정상 부하(단일 사용자, 로컬 테스트)에서 API는 200ms 이내 응답.
- 10개의 동시 결제 요청을 오류 없이 처리(Postman으로 테스트).

### 4.2 보안
- 비밀번호는 bcrypt로 해시 처리.
- 모든 결제 엔드포인트는 JWT 토큰으로 보호.
- 입력 검증으로 SQL 인젝션 및 유효하지 않은 데이터 방지.

### 4.3 확장성
- 트랜잭션 ID에 인덱싱을 적용해 미래 확장을 위한 데이터베이스 스키마 설계.
- Spring Boot의 스레드 풀을 사용해 동시 요청 효율적 처리.

### 4.4 유지보수성
- 클린 코드 원칙 준수(예: 의미 있는 변수명, 모듈화된 설계).
- 설정 및 사용 지침이 포함된 README와 인라인 주석 제공.
- Swagger로 API 문서화.

### 4.5 테스트
- JUnit으로 서비스 및 컨트롤러 레이어 단위 테스트(90% 이상 커버리지).
- Postman 스크립트로 API 엔드포인트 통합 테스트.
- 오류 시나리오(예: 유효하지 않은 토큰, 결제 실패)에 대한 수동 테스트.

## 5. 기술 스택

- **언어**: Kotlin
- **프레임워크**: Spring Boot
- **인증**: Spring Security with JWT
- **데이터베이스**: MySQL(프로덕션) 또는 H2(로컬 개발)
- **ORM**: JPA (Hibernate)
- **테스트**: JUnit, Postman
- **문서화**: Swagger, GitHub README
- **버전 관리**: Git

## 6. 사용자 스토리

1. **사용자로서**, 자격 증명으로 로그인하고 싶어, 결제 기능을 안전하게 이용할 수 있도록.
   - 수용 기준: 유효한 로그인 시 JWT 토큰 수령, 유효하지 않은 자격 증명 시 오류.
2. **사용자로서**, 제품에 대한 결제를 시작하고 싶어, 결제 프로세스를 시작할 수 있도록.
   - 수용 기준: 결제는 PENDING 상태로 생성, 유효하지 않은 입력은 거부.
3. **사용자로서**, 결제를 확인하고 싶어, 트랜잭션을 완료할 수 있도록.
   - 수용 기준: 결제는 SUCCESS 또는 FAILED로 업데이트, 실패 시 롤백.
4. **사용자로서**, 결제 상태를 확인하고 싶어, 트랜잭션 결과를 확인할 수 있도록.
   - 수용 기준: 유효한 ID로 세부 정보 수령, 유효하지 않은 ID는 오류.

## 7. 가정 및 제약

### 7.1 가정
- 사용자는 API 사용에 대한 기본 지식 보유(예: Postman 사용).
- 모의 제품 및 잔액 데이터로 시뮬레이션 충분.
- 로컬 개발은 H2 사용, MySQL은 포트폴리오 향상을 위해 선택 사항.

### 7.2 제약
- 백엔드 기능에 국한(프론트엔드 또는 실제 결제 게이트웨이 없음).
- 2-4주 타임라인의 단일 개발자 프로젝트.
- 환불, 다중 통화 등 고급 결제 기능 미지원.

## 8. 위험 및 완화

- **위험**: JWT 인증 구현 어려움.
  - **완화**: Spring Security 튜토리얼과 사전 구축 라이브러리 활용, 점진적 테스트.
- **위험**: 트랜잭션 처리의 동시성 문제.
  - **완화**: JPA 트랜잭션 격리 적용, 다중 요청 테스트.
- **위험**: 테스트 커버리지 부족.
  - **완화**: 코드와 함께 테스트 작성, JaCoCo와 같은 커버리지 도구 사용.

## 9. 마일스톤 및 타임라인

- **1주차**: Spring Boot 프로젝트 설정, Kotlin 구성, 인증 구현.
- **2주차**: 결제 시작 및 확인 API 개발, 데이터베이스 통합.
- **3주차**: 상태 조회 API, 오류 처리, 단위 테스트 구현.
- **4주차**: Swagger 문서화, 통합 테스트, GitHub README 완성.

## 10. 성공 지표

- 모든 사용자 스토리가 구현되고 수용 기준 통과.
- API는 90% 이상 테스트 커버리지를 달성하고 10개 동시 요청 처리.
- 프로젝트는 로컬에 배포되고 GitHub에 명확한 설정 지침으로 문서화.
- Kotlin, Spring Boot, 결제 도메인에 대한 개인 학습 목표 달성(포트폴리오에 반영).

## 11. 향후 개선

- 더 현실적인 시뮬레이션을 위해 모의 결제 게이트웨이 통합.
- Kafka를 사용한 비동기 결제 처리 지원.
- 실패한 결제에 대한 기본 재시도 메커니즘 구현.

---

**작성자**: [본인 이름, 직접 입력]  
**버전**: 1.0  
**날짜**: [본인 날짜, 직접 입력]  
**리포지토리**: [PaymentSimulator-Kotlin, 링크 추가 예정]
